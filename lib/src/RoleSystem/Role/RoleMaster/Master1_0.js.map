{"version":3,"sources":["../../../../../src/RoleSystem/Role/RoleMaster/Master1_0.es6"],"names":["instance","Master1_0","name","CONSTANT","DEFAULT_ROLES","MASTER_ROLE","id","pathToEntryFile","tasks","RoleAndTask","getInstance","getRoleTasks","setTaskHandler","TaskHandler","initProperties","communicationSystem","slaves","notConfirmedSlaves","consoleChildObjectPtr","newConnectionListeningFunction","newDisconnectionListeningFunction","cpuUsageAndMemory","tasksInfos","mutexes","func","filter","x","context","push","clientIdentityByte","clientIdentityString","body","regularSlaves","getSlavesOnlyThatAreRegularSlaves","limitToTaskList","forEach","some","y","isActive","includes","sendMessageToSlaveHeadBodyPattern","programIdentifier","PROTOCOL_MASTER_SLAVE","MESSAGES","GENERIC_CHANNEL_DATA","spreadDataToEveryLocalTask","data","sendDataToEveryPROGRAMTaskWhereverItIsLowLevel","err","slave","find","error","somethingChangedAboutSlavesOrI","PromiseCommandPattern","Errors","deserialize","Utils","displayMessage","str","String","stack","out","process","stderr","changeProgramState","DEFAULT_STATES","ERROR","tellHandleProgramTaskAboutSlaveError","getMakesErrorFatal","exitProgramUnproperDueToError","customFunctions","getMasterMutexFunctions","funcTake","funcRelease","TAKE_MUTEX","serialize","RELEASE_MUTEX","PROTOCOL_KEYWORDS","HEAD","BODY","SLAVE_CONFIRMATION_INFORMATIONS","OUTPUT_TEXT","INFOS_ABOUT_SLAVES","ERROR_HAPPENED","getCommunicationSystem","listenClientConnectionEvent","split","clientPID","cyan","closeConnectionToClient","sendMessageToClient","listenClientDisconnectionEvent","red","fireUp","confirmSlave","dataJSON","index","findIndex","role","splice","listenToIncomingMessage","dataString","convertStringToJSON","checkFunc","applyFunc","infosAboutSlaveIncomming","errorHappenedIntoSlave","protocolTakeMutex","protocolReleaseMutex","notConfirmedSlave","ptr","moreInfos","resolve","pid","map","idTaskToConnectTo","idTaskToConnect","args","monoline","blue","getTaskHandler","getTask","task","connection","connectToTask","green","identifierSlave","sendMessageAndWaitForTheResponse","isHeadBodyPattern","messageHeaderToSend","CONNECT_TASK_TO_TASK","messageBodyToSend","idTask","messageHeaderToGet","ret","identifier","status","xi","yi","START_TASK","modifyTaskStatusToSlaveLocalArray","master","getSlave","LIST_TASKS","getSlaveByProgramIdentifier","programState","oldProgramState","all","applyNewProgramState","tellAllSlaveThatProgramStateChanged","SLAVE_ROLE","tellASlaveThatProgramStateChanged","slaveIdentifier","STATE_CHANGE","timeoutToGetMessage","MASTER_MESSAGE_WAITING_TIMEOUT_STATE_CHANGE","identifiersSlaves","promiseQueue","functionToCall","sendMessageToSlave","CLOSE","kill","SIGNAL_UNPROPER","SIGUSR1","STOP_TASK","MASTER_MESSAGE_WAITING_TIMEOUT_STOP_TASK","param","displayTask","getDisplayLog","slaveOpts","specificOpts","connectionTimeout","reject","uniqueSlaveId","generateUniqueProgramID","programOpts","opts","PROGRAM_LAUNCHING_PARAMETERS","MODE","PROGRAM_LAUNCHING_MODE","SLAVE","MODE_OPTIONS","SLAVE_START_ARGS","IDENTIFIER","forkOpts","pathToExec","child","childProcess","fork","timeoutConnection","setTimeout","SIGNAL_TO_KILL_SLAVE_COMMAND","on","code","connectEvent","slaveInfos","clearTimeout","unlistenSlaveConnectionEvent","listenSlaveConnectionEvent","dynamicallyRefreshDataIntoList","confirmedSlaves","getTaskListStatus","communication","ips","givesLocalIps","cpuAndMemory","notifyAboutArchitectureChange","tellOneTaskAboutArchitectureChange","SLAVE_CREATION_CONNECTION_TIMEOUT","startNewSlaveInProcessMode","headString","bodyString","message","timeout","MASTER_MESSAGE_WAITING_TIMEOUT","timeoutFunction","msgListener","unlistenToIncomingMessage","intervalFdCpuAndMemory","DISPLAY_CPU_MEMORY_CHANGE_TIME","setInterval","getCpuAndMemoryLoad","active","clearInterval","errorHappened","intervalFdTasksInfos","taskHandler","getInfosFromAllActiveTasks","infos","SLAVES_INFOS_CHANGE_TIME","ipServer","ZERO_MQ","DEFAULT_SERVER_IP_ADDRESS","portServer","DEFAULT_SERVER_IP_PORT","ZeroMQServerRouter","start","transport","TRANSPORT","IPC","protocolMasterSlave","infiniteGetCpuAndMemory","infiniteGetTasksInfos","tasksMaster","computeListClosure","sortArray","closureHierarchy","idTaskToRemove","isMasterTask","isSlaveTask","hierarchyLevel","foundHighestInHierarchy","hierarchyY","getHierarchyLevelByIdTask","length","hierarchyX","chooseWhichTaskToStop","stopTask","stopAllTaskOnEverySlaveAndMaster","removeTaskFromSlave","removeExistingSlave","stop","sendMessageGoodFunc","errAlreadyReturned","getMessageFromSlave","then","catch","call","toRet","arr","i","tmp","AMaster"],"mappings":"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","file":"Master1_0.js","sourcesContent":["//\n// Copyright (c) 2016 by Cotep. All Rights Reserved.\n//\n\n// Imports\nimport childProcess from 'child_process';\nimport AMaster from './AMaster.js';\nimport CONSTANT from '../../../Utils/CONSTANT/CONSTANT.js';\nimport TaskHandler from '../../Handlers/TaskHandler.js';\nimport ZeroMQServerRouter from '../../../CommunicationSystem/SocketCommunicationSystem/ZeroMQ/Server/Implementations/ZeroMQServerRouter.js';\nimport Utils from '../../../Utils/Utils.js';\nimport Errors from '../../../Utils/Errors.js';\nimport RoleAndTask from '../../../RoleAndTask.js';\nimport PromiseCommandPattern from '../../../Utils/PromiseCommandPattern.js';\n\nlet instance = null;\n\n/**\n * Define the Role of Master which have a job of manager.\n *\n * Manage Slaves.\n */\nexport default class Master1_0 extends AMaster {\n  constructor() {\n    super();\n\n    if (instance) return instance;\n\n    this.name = CONSTANT.DEFAULT_ROLES.MASTER_ROLE.name;\n    this.id = CONSTANT.DEFAULT_ROLES.MASTER_ROLE.id;\n\n    this.pathToEntryFile = false;\n\n    // Get the tasks related to the master role\n    const tasks = RoleAndTask.getInstance()\n      .getRoleTasks(CONSTANT.DEFAULT_ROLES.MASTER_ROLE.id);\n\n    // Define all tasks handled by this role\n    this.setTaskHandler(new TaskHandler(tasks));\n\n    this.initProperties();\n\n    instance = this;\n\n    return instance;\n  }\n\n  /**\n   * Init the properties\n   */\n  initProperties() {\n    // Define none communicationSystem for now\n    this.communicationSystem = false;\n\n    // Array of current approved slaves\n    this.slaves = [];\n\n    // Array of slaves that are in the confirmation process\n    this.notConfirmedSlaves = [];\n\n    // Array that contains the relation between console process ptr and programIdentifier\n    // We use it too when there is no console launch, because it work with both soluce\n    this.consoleChildObjectPtr = [];\n\n    // Functions called when something happend to a slave connection\n    this.newConnectionListeningFunction = [];\n    this.newDisconnectionListeningFunction = [];\n\n    // Data we keep as attribute to give to handleProgramTask later\n    this.cpuUsageAndMemory = false;\n    this.tasksInfos = false;\n\n    // Store the mutexes here, we use to avoid concurrency between slaves on specific actions\n    this.mutexes = {};\n  }\n\n  /**\n   * Get the communicationSystem\n   */\n  getCommunicationSystem() {\n    return this.communicationSystem;\n  }\n\n  /**\n   * SINGLETON implementation\n   * @override\n   */\n  static getInstance() {\n    return instance || new Master1_0();\n  }\n\n  /**\n   * Pull a function that get fired when a slave get connected\n   */\n  unlistenSlaveConnectionEvent(func) {\n    this.newConnectionListeningFunction = this.newConnectionListeningFunction.filter(x => x.func !== func);\n  }\n\n  /**\n   * Pull a function that get fired when a slave get disconnected\n   */\n  unlistenSlaveDisconnectionEvent(func) {\n    this.newDisconnectionListeningFunction = this.newDisconnectionListeningFunction.filter(x => x.func !== func);\n  }\n\n  /**\n   * Push a function that get fired when a slave get connected\n   */\n  listenSlaveConnectionEvent(func, context) {\n    this.newConnectionListeningFunction.push({\n      func,\n      context,\n    });\n  }\n\n  /**\n   * Push a function that get fired when a slave get disconnected\n   */\n  listenSlaveDisconnectionEvent(func) {\n    this.newDisconnectionListeningFunction.push({\n      func,\n      context,\n    });\n  }\n\n  /**\n   * Return the array that contains non-confirmed slaves\n   */\n  getNonConfirmedSlaves() {\n    return this.notConfirmedSlaves;\n  }\n\n  /**\n   *  Get an array that contains confirmed slaves\n   */\n  getSlaves() {\n    return this.slaves;\n  }\n\n  /**\n   * We get asked to spread a news to every slave tasks and our tasks\n   *\n   * WARNING - DO NOT SEND IT TO NON-REGULAR SLAVES (CRON_EXECUTOR_ROLE FOR EXAMPLE)\n   *\n   * @param {[Byte]} clientIdentityByte\n   * @param {String} clientIdentityString\n   * @param {Object} data\n   */\n  sendDataToEveryPROGRAMTaskWhereverItIsLowLevel(clientIdentityByte, clientIdentityString, body) {\n    const regularSlaves = this.getSlavesOnlyThatAreRegularSlaves();\n\n    // Open the body to get the list of tasks we limit the spread on\n    const {\n      limitToTaskList,\n    } = body;\n\n\n    // For each slave\n    regularSlaves.forEach((x) => {\n      // Only send the data to the slaves that holds a tasks that need to know about the message\n      if (!limitToTaskList || x.tasks.some(y => y.isActive && limitToTaskList.includes(y.id))) {\n        // Send a message to every running slaves\n        this.sendMessageToSlaveHeadBodyPattern(x.programIdentifier, CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.GENERIC_CHANNEL_DATA, body);\n      }\n    });\n\n    // For itself tasks\n    RoleAndTask.getInstance()\n      .spreadDataToEveryLocalTask(body);\n  }\n\n  /**\n   * We get asked to spread a news to every slave tasks and our tasks\n   */\n  sendDataToEveryPROGRAMTaskWhereverItIs(data) {\n    this.sendDataToEveryPROGRAMTaskWhereverItIsLowLevel(false, false, data);\n  }\n\n  /**\n   * Tell the handleProgramTask about something happend in slaves\n   */\n  tellHandleProgramTaskAboutSlaveError(clientIdentityString, err) {\n    const slave = this.slaves.find(x => x.clientIdentityString === clientIdentityString);\n\n    if (!slave) return;\n\n    slave.error = err;\n    this.somethingChangedAboutSlavesOrI();\n  }\n\n  /**\n   * An error happended into a slave, what do we do?\n   * @param {Array} clientIdentityByte\n   * @param {String} clientIdentityString\n   * @param {String} body\n   */\n  errorHappenedIntoSlave(clientIdentityByte, clientIdentityString) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const err = Errors.deserialize(body);\n\n        // Display the error\n        Utils.displayMessage({\n          str: String((err && err.stack) || err),\n          out: process.stderr,\n        });\n\n        try {\n          // Get the client that got the problem\n          // We try to change the program state to error\n          await RoleAndTask.getInstance()\n            .changeProgramState(CONSTANT.DEFAULT_STATES.ERROR.id);\n\n          // We goodly changed the program state\n          // Add informations on error\n\n          Utils.displayMessage({\n            str: String((err && err.stack) || err),\n            out: process.stderr,\n          });\n\n          // Tell the task handleProgram that there had been an error for the slave\n          this.tellHandleProgramTaskAboutSlaveError(clientIdentityString, err);\n\n          // If the errors are supposed to be fatal, exit!\n          if (RoleAndTask.getInstance()\n            .getMakesErrorFatal()) {\n            RoleAndTask.exitProgramUnproperDueToError();\n          }\n          // We leave the process because something get broken\n        } catch (errNested) {\n          Utils.displayMessage({\n            str: 'Exit program unproper ERROR HAPPENED IN SLAVE',\n            out: process.stderr,\n          });\n\n          Utils.displayMessage({\n            str: String((errNested && errNested.stack) || errNested),\n            out: process.stderr,\n          });\n\n          RoleAndTask.exitProgramUnproperDueToError();\n        }\n      },\n    });\n  }\n\n  /**\n   * In master/slave protocol, we ask to get a token. We get directly asked as the master\n   */\n  takeMutex(id) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        // The mutex has already been taken\n        if (this.mutexes[id]) {\n          throw new Errors('E7024');\n        }\n\n        // Custom function to call when taking or releasing the mutex (if one got set by the user)\n        // If the function throw, we do not take the token\n        const customFunctions = RoleAndTask.getInstance()\n          .getMasterMutexFunctions()\n          .find(x => x.id === id);\n\n        if (customFunctions && customFunctions.funcTake) {\n          await customFunctions.funcTake();\n        }\n\n        this.mutexes[id] = true;\n      },\n    });\n  }\n\n  /**\n   * In master/slave protocol, we ask to release the token. We get directly asked as the master.\n   */\n  releaseMutex(id) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        // Custom function to call when taking or releasing the mutex (if one got set by the user)\n        // If the function throw, we do not take the token\n        const customFunctions = RoleAndTask.getInstance()\n          .getMasterMutexFunctions()\n          .find(x => x.id === id);\n\n        if (customFunctions && customFunctions.funcRelease) {\n          await customFunctions.funcRelease();\n        }\n\n        this.mutexes[id] = false;\n      },\n    });\n  }\n\n  /**\n   * Take the mutex behind the given ID if it's available\n   */\n  protocolTakeMutex(clientIdentityByte, clientIdentityString, body) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const {\n          TAKE_MUTEX,\n        } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n        // Det the slave that asked\n        const slave = this.slaves.find(x => x.clientIdentityString === clientIdentityString);\n\n        try {\n          // The mutex has already been taken\n          if (this.mutexes[body.id]) {\n            throw new Errors('E7024');\n          }\n\n          // Custom function to call when taking or releasing the mutex (if one got set by the user)\n          // If the function throw, we do not take the token\n          const customFunctions = RoleAndTask.getInstance()\n            .getMasterMutexFunctions()\n            .find(x => x.id === body.id);\n\n          if (customFunctions && customFunctions.funcTake) {\n            await customFunctions.funcTake();\n          }\n\n          this.mutexes[body.id] = true;\n\n          this.sendMessageToSlaveHeadBodyPattern(slave.programIdentifier, TAKE_MUTEX, JSON.stringify({\n            error: false,\n          }));\n        } catch (err) {\n          this.sendMessageToSlaveHeadBodyPattern(slave.programIdentifier, TAKE_MUTEX, JSON.stringify({\n            error: err.serialize(),\n          }));\n        }\n      },\n    });\n  }\n\n  /**\n   * Release the mutex behind the given ID\n   */\n  protocolReleaseMutex(clientIdentityByte, clientIdentityString, body) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const {\n          RELEASE_MUTEX,\n        } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n        // Det the slave that asked\n        const slave = this.slaves.find(x => x.clientIdentityString === clientIdentityString);\n\n        try {\n          // Custom function to call when taking or releasing the mutex (if one got set by the user)\n          // If the function throw, we do not take the token\n          const customFunctions = RoleAndTask.getInstance()\n            .getMasterMutexFunctions()\n            .find(x => x.id === body.id);\n\n          if (customFunctions && customFunctions.funcRelease) {\n            await customFunctions.funcRelease();\n          }\n\n          this.mutexes[body.id] = false;\n\n          this.sendMessageToSlaveHeadBodyPattern(slave.programIdentifier, RELEASE_MUTEX, JSON.stringify({\n            error: false,\n          }));\n        } catch (err) {\n          this.sendMessageToSlaveHeadBodyPattern(slave.programIdentifier, RELEASE_MUTEX, JSON.stringify({\n            error: err.serialize(),\n          }));\n        }\n      },\n    });\n  }\n\n  /**\n   * Define the master/slave basic protocol\n   * (Authentification)\n   */\n  protocolMasterSlave() {\n    // Shortcuts\n    const {\n      HEAD,\n      BODY,\n    } = CONSTANT.PROTOCOL_KEYWORDS;\n\n    const {\n      SLAVE_CONFIRMATION_INFORMATIONS,\n      GENERIC_CHANNEL_DATA,\n      OUTPUT_TEXT,\n      INFOS_ABOUT_SLAVES,\n      ERROR_HAPPENED,\n      TAKE_MUTEX,\n      RELEASE_MUTEX,\n    } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n    // Listen at new Socket connection\n    //\n    // 1/ Check if the new slave have a correct identifier\n    // 2/ Ask the slave for running tasks\n    // 3/ Get the slave answer\n    // 4/ Add the slave into handled slave\n    //\n    this.getCommunicationSystem()\n      .listenClientConnectionEvent((clientIdentityByte, clientIdentityString) => {\n        const [\n          programIdentifier,\n          clientPID,\n        ] = clientIdentityString.split('_');\n\n        // Look at the identity of the slave (and if we have duplicate)\n        if (this.slaves.find(x => x.programIdentifier === programIdentifier) ||\n          this.notConfirmedSlaves.find(x => x.programIdentifier === programIdentifier)) {\n          // Identity already in use by an other slave\n          // Close the connection\n          RoleAndTask.getInstance()\n            .displayMessage({\n              str: `[${this.name}] Refuse slave cause of identity`.cyan,\n            });\n\n          return this.getCommunicationSystem()\n            .closeConnectionToClient(clientIdentityByte, clientIdentityString);\n        }\n\n        // So here the client do not exist already and the identifier is free\n\n        // Add the slave into the declared not confirmed array\n        this.notConfirmedSlaves.push({\n          clientIdentityString,\n          clientIdentityByte,\n          programIdentifier,\n          clientPID,\n          tasks: [],\n          error: false,\n        });\n\n        // Ask the slaves about its tasks\n        return this.getCommunicationSystem()\n          .sendMessageToClient(clientIdentityByte, clientIdentityString, SLAVE_CONFIRMATION_INFORMATIONS);\n      });\n\n    // Listen to slaves disconnection\n    this.getCommunicationSystem()\n      .listenClientDisconnectionEvent((clientIdentityString) => {\n        this.slaves = this.slaves.filter((x) => {\n          if (x.clientIdentityString === clientIdentityString) {\n            RoleAndTask.getInstance()\n              .displayMessage({\n                str: `[${this.name}] Slave get removed (connection)`.red,\n              });\n\n            // Fire when a slave get disconnected\n            Utils.fireUp(this.newDisconnectionListeningFunction, [x]);\n\n            return false;\n          }\n\n          return true;\n        });\n\n        this.notConfirmedSlaves = this.notConfirmedSlaves.filter((x) => {\n          if (x.clientIdentityString === clientIdentityString) {\n            RoleAndTask.getInstance()\n              .displayMessage({\n                str: `[${this.name}] Non-confirmed slave get removed (connection)`.red,\n              });\n\n            // Fire when a slave get disconnected\n            Utils.fireUp(this.newDisconnectionListeningFunction, [x]);\n\n            return false;\n          }\n\n          return true;\n        });\n      });\n\n    // Confirm a slave that wasn't\n    const confirmSlave = (clientIdentityByte, clientIdentityString, dataJSON) => {\n      const index = this.notConfirmedSlaves.findIndex(x => x.clientIdentityString === clientIdentityString);\n\n      if (index === -1) return;\n\n      // Confirm the slave\n      const slave = this.notConfirmedSlaves[index];\n\n      slave.tasks = dataJSON[BODY].tasks;\n      slave.role = dataJSON[BODY].role;\n\n      this.slaves.push(slave);\n\n      this.notConfirmedSlaves.splice(index, 1);\n\n      // Fire when a slave get connected\n      Utils.fireUp(this.newConnectionListeningFunction, [slave]);\n    };\n\n    // We listen to incoming messages\n    this.getCommunicationSystem()\n      .listenToIncomingMessage((clientIdentityByte, clientIdentityString, dataString) => {\n        const dataJSON = Utils.convertStringToJSON(dataString);\n\n        // Here we got all messages that comes from clients (so slaves)\n        // Check if the message answer particular message\n        // If it does apply the particular job\n        [{\n          //\n          // Check about the slave infos\n          //\n          checkFunc: () => (dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === SLAVE_CONFIRMATION_INFORMATIONS),\n          // It means we get the tasks list\n          applyFunc: () => confirmSlave(clientIdentityByte, clientIdentityString, dataJSON),\n        }, {\n          //\n          // Check about generic news\n          //\n          checkFunc: () => (dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === GENERIC_CHANNEL_DATA),\n          applyFunc: () => this.sendDataToEveryPROGRAMTaskWhereverItIsLowLevel(clientIdentityByte, clientIdentityString, dataJSON[BODY]),\n        }, {\n          //\n          // Check about messages to display\n          //\n          checkFunc: () => (dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === OUTPUT_TEXT),\n          applyFunc: () => this.displayMessage(dataJSON[BODY]),\n        }, {\n          //\n          // Check about infos about slaves\n          //\n          checkFunc: () => (dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === INFOS_ABOUT_SLAVES),\n          applyFunc: () => this.infosAboutSlaveIncomming(clientIdentityByte, clientIdentityString, dataJSON[BODY]),\n        }, {\n          //\n          // Check about error happened into slave\n          //\n          checkFunc: () => (dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === ERROR_HAPPENED),\n          applyFunc: () => this.errorHappenedIntoSlave(clientIdentityByte, clientIdentityString, dataJSON[BODY]),\n        }, {\n          //\n          // Check about slave asking for taking a mutex\n          //\n          checkFunc: () => (dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === TAKE_MUTEX),\n          applyFunc: () => this.protocolTakeMutex(clientIdentityByte, clientIdentityString, dataJSON[BODY]),\n        }, {\n          //\n          // Check about slave asking for releasing a mutex\n          //\n          checkFunc: () => (dataJSON && dataJSON[HEAD] && dataJSON[HEAD] === RELEASE_MUTEX),\n          applyFunc: () => this.protocolReleaseMutex(clientIdentityByte, clientIdentityString, dataJSON[BODY]),\n        }].forEach((x) => {\n          if (x.checkFunc()) x.applyFunc();\n        });\n      });\n  }\n\n  /**\n   * We got news about a slave -> infos\n   * Store it and call HandleProgramTask if it's up\n   * @param {Object} clientIdentityByte\n   * @param {String} clientIdentityString\n   * @param {Object} data\n   */\n  infosAboutSlaveIncomming(clientIdentityByte, clientIdentityString, data) {\n    // Get the right slave\n    const slave = this.slaves.find(x => x.clientIdentityString === clientIdentityString);\n    const notConfirmedSlave = this.notConfirmedSlaves.find(x => x.clientIdentityString === clientIdentityString);\n\n    const ptr = slave || notConfirmedSlave;\n\n    if (!ptr) return;\n\n    if (!ptr.moreInfos) ptr.moreInfos = {};\n\n    // Apply values to moreInfos\n    [\n      'cpuAndMemory',\n      'ips',\n      'tasksInfos',\n    ]\n    .forEach((x) => {\n      // To get the 0 value\n      if (data[x] !== void 0) ptr.moreInfos[x] = data[x];\n    });\n\n    // Tell something changed in the conf\n    this.somethingChangedAboutSlavesOrI();\n  }\n\n  /**\n   * Returns in an array the whole system pids (Master + Slaves processes)\n   */\n  getFullSystemPids() {\n    return new PromiseCommandPattern({\n      func: () => new Promise((resolve) => {\n        resolve([\n          String(process.pid),\n          ...this.slaves.map(x => String(x.clientPID)),\n        ]);\n      }),\n    });\n  }\n\n  /**\n   * Connect the second Task to the first one\n   * @param {String} idTaskToConnectTo\n   * @param {String} idTaskToConnect\n   * @param {Object} args\n   */\n  connectMasterToTask(idTaskToConnectTo, idTaskToConnect, args) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        try {\n          RoleAndTask.getInstance()\n            .displayMessage({\n              str: Utils.monoline([\n                  `[${this.name}] Ask Master to connect the Task N${idTaskToConnect}`,\n                  ` to the Task N${idTaskToConnectTo}`,\n                ])\n                .blue,\n            });\n\n          const task = await this.getTaskHandler()\n            .getTask(idTaskToConnectTo);\n\n          // We get the task\n          // Error if the task is not active\n          if (!task.isActive()) {\n            throw new Errors('E7009', `idTask: ${idTaskToConnectTo}`);\n          }\n\n          // Ask the connection to be made\n          const connection = task.connectToTask(idTaskToConnect, args);\n\n          RoleAndTask.getInstance()\n            .displayMessage({\n              str: Utils.monoline([\n                  `[${this.name}] Task N${idTaskToConnect} correctly connected to Task `,\n                  `N${idTaskToConnectTo} in Master`,\n                ])\n                .green,\n            });\n\n          return connection;\n        } catch (err) {\n          RoleAndTask.getInstance()\n            .displayMessage({\n              str: Utils.monoline([\n                  `[${this.name}] Task N${idTaskToConnect} failed to be connected`,\n                  ` to Task N${idTaskToConnectTo} in Master`,\n                ])\n                .red,\n            });\n\n          throw err;\n        }\n      },\n    });\n  }\n\n  /**\n   * Connect the second Task to the first one\n   * @param {String} identifierSlave - Identifier of the slave that host the idTaskToConnectTo\n   * @param {String} idTaskToConnectTo\n   * @param {String} idTaskToConnect\n   * @param {Object} args\n   */\n  connectTaskToTask(identifierSlave, idTaskToConnectTo, idTaskToConnect, args) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const ret = await this.sendMessageAndWaitForTheResponse({\n          identifierSlave,\n          isHeadBodyPattern: true,\n          messageHeaderToSend: CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.CONNECT_TASK_TO_TASK,\n\n          messageBodyToSend: {\n            idTask: idTaskToConnectTo,\n            idTaskToConnect,\n            args,\n          },\n\n          messageHeaderToGet: CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.CONNECT_TASK_TO_TASK,\n        });\n\n        // We get either an errors object or an error\n        if (ret === '') return ret;\n\n        throw ret;\n      },\n    });\n  }\n\n  /**\n   * Modify the status of the task attached to the given identifier\n   * (local data, have no impact in the real slave)\n   * @param {String} identifier\n   * @param {String} idTask\n   * @param {Boolean} status\n   */\n  modifyTaskStatusToSlaveLocalArray(identifier, idTask, status) {\n    this.slaves.some((x, xi) => {\n      if (x.programIdentifier === identifier) {\n        return x.tasks.some((y, yi) => {\n          if (y.id === idTask) {\n            this.slaves[xi].tasks[yi].isActive = status;\n\n            return true;\n          }\n\n          return false;\n        });\n      }\n\n      return false;\n    });\n  }\n\n  /**\n   * When called: Add a task to a slave\n   * @param {String} identifier\n   * @param {String} idTask\n   */\n  startTaskToSlave(identifier, idTask, args = {}) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const ret = await this.sendMessageAndWaitForTheResponse({\n          identifierSlave: identifier,\n          isHeadBodyPattern: true,\n          messageHeaderToSend: CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.START_TASK,\n\n          messageBodyToSend: {\n            idTask,\n            args,\n          },\n\n          messageHeaderToGet: CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.START_TASK,\n        });\n\n        // We get either an errors object or an error\n        if (ret === '') {\n          // Modify the task status for the given slave\n          this.modifyTaskStatusToSlaveLocalArray(identifier, idTask, true);\n\n          // Say something changed\n          this.somethingChangedAboutSlavesOrI();\n\n          return ret;\n        }\n\n        throw Errors.deserialize(ret);\n      },\n    });\n  }\n\n  /**\n   * List the existing slaves\n   */\n  listSlaves() {\n    return new PromiseCommandPattern({\n      func: () => this.master.getSlave(),\n    });\n  }\n\n  /**\n   * List a slave tasks using its identifier (Ask the slave to it)\n   * @param {String} identifier\n   */\n  distantListSlaveTask(identifier) {\n    return new PromiseCommandPattern({\n      func: () => this.sendMessageAndWaitForTheResponse({\n        identifierSlave: identifier,\n        isHeadBodyPattern: false,\n        messageHeaderToSend: CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.LIST_TASKS,\n        messageBodyToSend: {},\n        messageHeaderToGet: CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.LIST_TASKS,\n      }),\n    });\n  }\n\n  /**\n   * List a slave tasks using its identifier (Use local data to it)\n   * @param {String} identifier\n   */\n  listSlaveTask(identifier) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        // Look for the slave in confirmSlave\n        const slave = this.getSlaveByProgramIdentifier(identifier);\n\n        return slave.tasks;\n      },\n    });\n  }\n\n  /**\n   * Handle the fact the program state change\n   * We spread the data on our tasks and to our slaves\n   * @param {Number} programState\n   * @param {Number} oldProgramState\n   */\n  handleProgramStateChange(programState, oldProgramState) {\n    return new PromiseCommandPattern({\n      func: () => Promise.all([\n        // Spread to our tasks\n        this.getTaskHandler()\n        .applyNewProgramState(programState, oldProgramState),\n\n        // Spread to slaves\n        this.tellAllSlaveThatProgramStateChanged(programState, oldProgramState),\n\n        // The spread n slaves went well\n      ]),\n    });\n  }\n\n  /**\n   * Return only the slaves that are regular slaves (not CRON_EXECUTOR_ROLE for example)\n   */\n  getSlavesOnlyThatAreRegularSlaves() {\n    return this.slaves.filter(x => x.role.id === CONSTANT.DEFAULT_ROLES.SLAVE_ROLE.id);\n  }\n\n  /**\n   * Tell all slave that the program state did change\n   *\n   * WARNING - DO NOT INCLUDE CRON_EXECUTOR_ROLE SLAVES INTO THE PIPE\n   *\n   * @param {Number} programState\n   * @param {Number} oldProgramState\n   */\n  tellAllSlaveThatProgramStateChanged(programState, oldProgramState) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const regularSlaves = this.getSlavesOnlyThatAreRegularSlaves();\n\n        return Promise.all(regularSlaves.map(x => this.tellASlaveThatProgramStateChanged(x.programIdentifier, programState, oldProgramState)));\n      },\n    });\n  }\n\n  /**\n   * Tell a slave that program state did change\n   * @param {String} slaveIdentifier\n   * @param {Number} programState\n   * @param {Number} oldProgramState\n   */\n  tellASlaveThatProgramStateChanged(slaveIdentifier, programState, oldProgramState) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const {\n          STATE_CHANGE,\n        } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n        const ret = await this.sendMessageAndWaitForTheResponse({\n          identifierSlave: slaveIdentifier,\n          isHeadBodyPattern: true,\n          messageHeaderToSend: STATE_CHANGE,\n\n          messageBodyToSend: {\n            programState,\n            oldProgramState,\n          },\n\n          messageHeaderToGet: STATE_CHANGE,\n          timeoutToGetMessage: CONSTANT.MASTER_MESSAGE_WAITING_TIMEOUT_STATE_CHANGE,\n        });\n\n        // We get either an errors object or an error\n        if (ret === '') return ret;\n\n        RoleAndTask.getInstance()\n          .displayMessage({\n            str: `[${this.name}] program state get not spread in Slave N${slaveIdentifier}`.red,\n          });\n\n        throw Errors.deserialize(ret);\n      },\n    });\n  }\n\n  /**\n   * When called: Remove an existing slave(s)\n   * @param {Array} identifiersSlaves\n   * @param {?Number} _i\n   */\n  removeExistingSlave(identifiersSlaves) {\n    return new PromiseCommandPattern({\n      func: () => Utils.promiseQueue([\n        // Close all slaves\n        ...identifiersSlaves.map(x => ({\n          functionToCall: this.sendMessageToSlave,\n\n          context: this,\n\n          args: [\n            x,\n            CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES.CLOSE,\n          ],\n        })),\n\n        // Say that something changed\n        {\n          functionToCall: this.somethingChangedAboutSlavesOrI,\n          context: this,\n        },\n      ]),\n    });\n  }\n\n  /**\n   * Kill a slave using its identifier\n   * @param {String} programIdentifier\n   */\n  killSlave(programIdentifier) {\n    // Look for the given identifier\n    this.consoleChildObjectPtr.filter((x) => {\n      if (x.programIdentifier === programIdentifier) {\n        try {\n          // Kill the process\n          process.kill(x.pid, CONSTANT.SIGNAL_UNPROPER.SIGUSR1);\n\n          // Remove the slave from the slave list\n          this.slaves = this.slaves.filter(y => !(y.programIdentifier === programIdentifier));\n        } catch (err) {\n          // Ignore the error, because the slave is dead anyway to us\n        }\n\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  /**\n   * When called: remove a task from slave\n   *\n   * THIS FUNCTION HAVE SPECIAL TIMEOUT FOR SLAVE ANSWER\n   *\n   * @param {String} identifier\n   * @param {String} idTask\n   * @param {Object} args\n   */\n  removeTaskFromSlave(identifier, idTask, args = {}) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const {\n          STOP_TASK,\n        } = CONSTANT.PROTOCOL_MASTER_SLAVE.MESSAGES;\n\n        RoleAndTask.getInstance()\n          .displayMessage({\n            str: `[${this.name}] Ask Slave N${identifier} to stop the Task N${idTask}`.blue,\n          });\n\n        const ret = await this.sendMessageAndWaitForTheResponse({\n          identifierSlave: identifier,\n          isHeadBodyPattern: true,\n          messageHeaderToSend: STOP_TASK,\n\n          messageBodyToSend: {\n            idTask,\n            args,\n          },\n\n          messageHeaderToGet: STOP_TASK,\n          timeoutToGetMessage: CONSTANT.MASTER_MESSAGE_WAITING_TIMEOUT_STOP_TASK,\n        });\n\n        // We get either an errors object or an error\n        if (ret === '') {\n          RoleAndTask.getInstance()\n            .displayMessage({\n              str: `[${this.name}] Task N${idTask} correctly stopped in Slave N${identifier}`.green,\n            });\n\n          // Modify the task status for the given slave\n          this.modifyTaskStatusToSlaveLocalArray(identifier, idTask, false);\n\n          return ret;\n        }\n\n        RoleAndTask.getInstance()\n          .displayMessage({\n            str: `[${this.name}] Task N${idTask} failed to be stopped to Slave N${identifier}`.red,\n          });\n\n        throw ret;\n      },\n    });\n  }\n\n  /**\n   * Display a message directly\n   * @param {Object} param\n   */\n  displayMessage(param) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        try {\n          // If we have the display task active, we give the message to it\n          if (this.displayTask) {\n            const task = await this.getTaskHandler()\n              .getTask(this.displayTask);\n\n            // If we disallow log display, stop it here\n            if (!RoleAndTask.getInstance()\n              .getDisplayLog()) {\n              return false;\n            }\n\n            if (task.isActive()) {\n              return task.displayMessage(param);\n            }\n          }\n\n          // If not we display\n          Utils.displayMessage(param);\n        } catch (err) {\n          // Ignore error - We can't display the data - it do not require further error treatment\n          // Store the message into file tho\n          Utils.displayMessage({\n            str: String(err.stack || err),\n            out: process.stderr,\n          });\n        }\n\n        return false;\n      },\n    });\n  }\n\n  /**\n   * Start a new slave not in a console but in a regular process\n   * @param {{opts: String, uniqueSlaveId: String}} slaveOpts\n   * @param {Object} specificOpts - (Spawn options)\n   * @param {String} connectionTimeout\n   */\n  startNewSlaveInProcessMode(slaveOpts, specificOpts, connectionTimeout) {\n    return new PromiseCommandPattern({\n      func: () => new Promise((resolve, reject) => {\n        // We create a unique Id that will referenciate the slave at the connexion\n        const uniqueSlaveId = (slaveOpts && slaveOpts.uniqueSlaveId) || Utils.generateUniqueProgramID();\n\n        // Options to send to the new created slave\n        const programOpts = (slaveOpts && slaveOpts.opts) || [\n          `--${CONSTANT.PROGRAM_LAUNCHING_PARAMETERS.MODE.name}`,\n          `${CONSTANT.PROGRAM_LAUNCHING_MODE.SLAVE}`,\n          `--${CONSTANT.PROGRAM_LAUNCHING_PARAMETERS.MODE_OPTIONS.name}`,\n          `${CONSTANT.SLAVE_START_ARGS.IDENTIFIER}=${uniqueSlaveId}`,\n        ];\n\n        // Options to give to fork(...)\n        const forkOpts = {};\n\n        // If there is no path to the entry file to execute\n        if (!this.pathToEntryFile) {\n          throw new Errors('EXXXX', 'Cannot start the slave : No pathToEntryFile configured');\n        }\n\n        // Path that lead to the exe of PROGRAM\n        const pathToExec = this.pathToEntryFile;\n\n        // LaunchScenarios program in slave mode in a different process\n        const child = childProcess.fork(pathToExec, programOpts, forkOpts);\n\n        // LaunchScenarios a timeout of connection\n        const timeoutConnection = setTimeout(() => {\n          // Kill the process we did created\n          child.kill(CONSTANT.SIGNAL_TO_KILL_SLAVE_COMMAND);\n\n          return reject(new Errors('E7003', `Timeout ${connectionTimeout} ms passed`));\n        }, connectionTimeout);\n\n        // Look at error event (If it get fired it means the program failed to get launched)\n        // Handle the fact a child can result an error later on after first connection\n        // Error detected\n        child.on('error', err => reject(new Errors('E7003', `Exit Code: ${err}`)));\n\n        // Handle the fact a child get closed\n        // The close can be wanted, or not\n        child.on('close', (code) => {\n          // No error\n          RoleAndTask.getInstance()\n            .displayMessage({\n              str: `Slave Close: ${code}`.red,\n            });\n        });\n\n        // Handle the fact a child exit\n        // The exit can be wanted or not\n        child.on('exit', (code) => {\n          // No error\n          RoleAndTask.getInstance()\n            .displayMessage({\n              str: `Slave Exit: ${code}`.red,\n            });\n        });\n\n        // Now we need to look at communicationSystem of the master to know if the new slave connect to PROGRAM\n        // If we pass a connection timeout time, we kill the process we just created and return an error\n        const connectEvent = (slaveInfos) => {\n          // Wait for a new client with the identifier like -> uniqueSlaveId_processId\n          if (slaveInfos && slaveInfos.programIdentifier === uniqueSlaveId) {\n            // We got our slave working well\n            clearTimeout(timeoutConnection);\n            this.unlistenSlaveConnectionEvent(connectEvent);\n\n            // Store the child data\n            this.consoleChildObjectPtr.push({\n              programIdentifier: uniqueSlaveId,\n              pid: slaveInfos.clientPID,\n            });\n\n            return resolve({\n              ...slaveInfos,\n              pid: slaveInfos.clientPID,\n            });\n          }\n\n          // This is not our slave\n\n          return false;\n        };\n\n        this.listenSlaveConnectionEvent(connectEvent);\n      }),\n    });\n  }\n\n  /**\n   * Tell one task about what changed in the architecture\n   */\n  tellOneTaskAboutArchitectureChange(idTask) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        try {\n          const task = await this.getTaskHandler()\n            .getTask(idTask);\n\n          // Can't find the task  so -> don't tell a new archiecture is here\n          if (!task) return;\n\n          if (task.isActive()) {\n            // Tell HandleProgramTask about new conf\n            task.dynamicallyRefreshDataIntoList({\n              notConfirmedSlaves: this.notConfirmedSlaves,\n              confirmedSlaves: this.slaves,\n\n              master: {\n                tasks: this.getTaskHandler()\n                  .getTaskListStatus(),\n                communication: this.getCommunicationSystem(),\n                ips: Utils.givesLocalIps(),\n                cpuAndMemory: this.cpuUsageAndMemory,\n                tasksInfos: this.tasksInfos,\n              },\n            });\n          }\n        } catch (e) {\n          // Don't od anything because it's not an error\n        }\n      },\n    });\n  }\n\n  /**\n   * Do something when an information changed about PROGRAM architecture\n   */\n  somethingChangedAboutSlavesOrI() {\n    return new PromiseCommandPattern({\n      func: async () => {\n        // Look at all tasks\n        await Promise.all(RoleAndTask.getInstance()\n          .tasks.filter(x => x.notifyAboutArchitectureChange)\n          .map(x => this.tellOneTaskAboutArchitectureChange(x.id)));\n      },\n    });\n  }\n\n  /**\n   * When called : start a new slave\n   * Take options in parameters or start a regular slave\n   *\n   * @param {{opts: String, uniqueSlaveId: String}} slaveOpts\n   * @param {Object} specificOpts - (Spawn options)\n   * @param {String} connectionTimeout\n   */\n  startNewSlave(slaveOpts, specificOpts, connectionTimeout = CONSTANT.SLAVE_CREATION_CONNECTION_TIMEOUT) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        const ret = await this.startNewSlaveInProcessMode(slaveOpts, specificOpts, connectionTimeout);\n\n        // Say something changed\n        await this.somethingChangedAboutSlavesOrI();\n\n        return ret;\n      },\n    });\n  }\n\n  /**\n   * Send a message that match head/body pattern\n   *\n   * Messages are like: { head: Object, body: Object }\n   *\n   * @param {String} programIdentifier\n   * @param {String} headString\n   * @param {String} bodyString\n   */\n  sendMessageToSlaveHeadBodyPattern(programIdentifier, headString, bodyString) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        // Build up the message\n        const message = {\n          [CONSTANT.PROTOCOL_KEYWORDS.HEAD]: headString,\n          [CONSTANT.PROTOCOL_KEYWORDS.BODY]: bodyString,\n        };\n\n        // Send the message\n        return this.sendMessageToSlave(programIdentifier, JSON.stringify(message));\n      },\n    });\n  }\n\n  /**\n   * Send a message to a slave using an programIdentifier\n   * @param {String} programIdentifier\n   * @param {String} message\n   */\n  sendMessageToSlave(programIdentifier, message) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        // Look for the slave in confirmSlave\n        const slave = this.getSlaveByProgramIdentifier(programIdentifier);\n\n        // Send the message\n        this.getCommunicationSystem()\n          .sendMessageToClient(slave.clientIdentityByte, slave.clientIdentityString, message);\n\n        return true;\n      },\n    });\n  }\n\n  /**\n   * Get a slave using its program id\n   * @param {String} programIdentifier\n   */\n  getSlaveByProgramIdentifier(programIdentifier) {\n    // Look for the slave in confirmSlave\n    const slave = this.slaves.find(x => x.programIdentifier === programIdentifier);\n\n    return slave || new Errors('E7004', `Identifier: ${programIdentifier}`);\n  }\n\n  /**\n   * Using the programIdentifier, wait a specific incoming message from a specific slave\n   *\n   * Messages are like: { head: Object, body: Object }\n   *\n   * If there is no answer before the timeout, stop waiting and send an error\n   * @param {String} headString\n   * @param {String} programIdentifier\n   * @param {Number} timeout - in ms\n   */\n  getMessageFromSlave(headString, programIdentifier, timeout = CONSTANT.MASTER_MESSAGE_WAITING_TIMEOUT) {\n    return new PromiseCommandPattern({\n      func: () => new Promise((resolve, reject) => {\n        let timeoutFunction = false;\n\n        // Look for the slave in confirmSlave\n        const slave = this.getSlaveByProgramIdentifier(programIdentifier);\n\n        // Function that will receive messages from slaves\n        const msgListener = (clientIdentityByte, clientIdentityString, dataString) => {\n          // Check the identifier to be the one we are waiting a message for\n\n          if (clientIdentityString === slave.clientIdentityString) {\n            const dataJSON = Utils.convertStringToJSON(dataString);\n\n            // Here we got all messages that comes from clients (so slaves)\n            // Check if the message answer particular message\n            if (dataJSON && dataJSON[CONSTANT.PROTOCOL_KEYWORDS.HEAD] &&\n              dataJSON[CONSTANT.PROTOCOL_KEYWORDS.HEAD] === headString) {\n              // Stop the timeout\n              clearTimeout(timeoutFunction);\n\n              // Stop the listening\n              this.getCommunicationSystem()\n                .unlistenToIncomingMessage(msgListener);\n\n              // We get our message\n              return resolve(dataJSON[CONSTANT.PROTOCOL_KEYWORDS.BODY]);\n            }\n          }\n\n          return false;\n        };\n\n        // If the function get triggered, we reject an error\n        timeoutFunction = setTimeout(() => {\n          // Stop the listening\n          this.getCommunicationSystem()\n            .unlistenToIncomingMessage(msgListener);\n\n          // Return an error\n          return reject(new Errors('E7005'));\n        }, timeout);\n\n        // Listen to incoming messages\n        return this.getCommunicationSystem()\n          .listenToIncomingMessage(msgListener);\n      }),\n    });\n  }\n\n  /**\n   * Send the cpu load to the server periodically\n   */\n  infiniteGetCpuAndMemory() {\n    return new PromiseCommandPattern({\n      func: async () => {\n        if (this.intervalFdCpuAndMemory) return;\n\n        if (CONSTANT.DISPLAY_CPU_MEMORY_CHANGE_TIME) {\n          // When we connect, we send our infos to the master\n          this.intervalFdCpuAndMemory = setInterval(async () => {\n            try {\n              const cpuAndMemory = await Utils.getCpuAndMemoryLoad();\n\n              this.cpuUsageAndMemory = cpuAndMemory;\n\n              // Say something change\n              this.somethingChangedAboutSlavesOrI();\n\n              if (!this.active && this.intervalFdCpuAndMemory) {\n                clearInterval(this.intervalFdCpuAndMemory);\n\n                this.intervalFdCpuAndMemory = false;\n              }\n            } catch (err) {\n              RoleAndTask.getInstance()\n                .errorHappened(err);\n            }\n          }, CONSTANT.DISPLAY_CPU_MEMORY_CHANGE_TIME);\n        }\n      },\n    });\n  }\n\n  /**\n   * Get periodically the infos about tasks running in master\n   */\n  infiniteGetTasksInfos() {\n    if (this.intervalFdTasksInfos) return;\n\n    this.intervalFdTasksInfos = setInterval(async () => {\n      try {\n        const infos = await this.taskHandler.getInfosFromAllActiveTasks();\n\n        this.tasksInfos = infos;\n\n        this.somethingChangedAboutSlavesOrI();\n\n        // If the role is still active we call it back\n        if (!this.active && this.intervalFdTasksInfos) {\n          clearInterval(this.intervalFdTasksInfos);\n\n          this.intervalFdTasksInfos = false;\n        }\n      } catch (err) {\n        RoleAndTask.getInstance()\n          .errorHappened(err);\n      }\n    }, CONSTANT.SLAVES_INFOS_CHANGE_TIME);\n  }\n\n  /**\n   * PROGRAM start to play the role\n   *\n   * A master is defined as:\n   * A master have a Server ZeroMQ open\n   * A master is connected to Slaves\n   *\n   * pathToEntryFile is the path we will use to start new slaves\n   *\n   * @param {Object} args\n   * @override\n   */\n  start({\n    ipServer = CONSTANT.ZERO_MQ.DEFAULT_SERVER_IP_ADDRESS,\n    portServer = CONSTANT.ZERO_MQ.DEFAULT_SERVER_IP_PORT,\n  }) {\n    return new PromiseCommandPattern({\n      func: async () => {\n        // Reinitialize some properties\n        this.initProperties();\n\n        // Create the OMQ Server\n        this.communicationSystem = new ZeroMQServerRouter();\n\n        // Start the communication system\n        await this.communicationSystem.start({\n          ipServer,\n          portServer,\n          transport: CONSTANT.ZERO_MQ.TRANSPORT.IPC,\n        });\n\n        this.active = true;\n\n        this.protocolMasterSlave();\n\n        // Say something changed\n        this.somethingChangedAboutSlavesOrI();\n\n        // LaunchScenarios an infite get of cpu usage to give to handleProgramTask\n        this.infiniteGetCpuAndMemory();\n\n        // LaunchScenarios an infite get of tasks infos to give to handleProgramTask\n        this.infiniteGetTasksInfos();\n\n        return true;\n      },\n    });\n  }\n\n  /**\n   * Get the hierarchy level of the given task\n   */\n  static getHierarchyLevelByIdTask(computeListClosure, idTask) {\n    let toRet;\n\n    computeListClosure.some((x) => {\n      if (x.idTask === idTask) {\n        toRet = x.closureHierarchy;\n\n        return true;\n      }\n\n      return false;\n    });\n\n    return toRet;\n  }\n\n  /**\n   * Sort the array ASC by closureHierarchy\n   */\n  static sortArray(ptr) {\n    const arr = ptr;\n\n    for (let i = 0; i < (arr.length - 1); i += 1) {\n      if (arr[i].closureHierarchy > arr[i + 1].closureHierarchy) {\n        const tmp = arr[i + 1];\n\n        arr[i + 1] = arr[i];\n\n        arr[i] = tmp;\n\n        i = -1;\n      }\n    }\n\n    return arr;\n  }\n\n  /**\n   * This methods return the task we need to stop first\n   * There is an hierarchie in tasks closure\n   */\n  chooseWhichTaskToStop() {\n    const tasksMaster = this.getTaskHandler()\n      .getTaskListStatus();\n\n    // Compute a list in order of tasksID to close (following the closure hierarchy)\n    const computeListClosure = Master1_0.sortArray(tasksMaster.map(x => ({\n      idTask: x.id,\n      closureHierarchy: x.closureHierarchy,\n    })));\n\n    // Now look at slaves tasks, then master task, about the task that is the higher in closure hierarchy\n    const ret = {\n      idTaskToRemove: false,\n      isMasterTask: false,\n      isSlaveTask: false,\n      identifierSlave: false,\n      hierarchyLevel: false,\n      args: {},\n    };\n\n    const foundHighestInHierarchy = this.slaves.some(x => x.tasks.some((y) => {\n      // Look at the hierarchy level of the given task\n      const hierarchyY = Master1_0.getHierarchyLevelByIdTask(computeListClosure, y.id);\n\n      if (!y.isActive) return false;\n\n      // Look if this hierarchy is higher than the save one\n      if (ret.hierarchyLevel === false || (ret.hierarchyLevel > hierarchyY)) {\n        // Save the task to be the one that get to be removed (for now!)\n        ret.hierarchyLevel = hierarchyY;\n        ret.idTaskToRemove = y.id;\n        ret.isSlaveTask = true;\n        ret.isMasterTask = false;\n        ret.identifierSlave = x.programIdentifier;\n\n        // If the task we have is the highest in hierarchy, no need to look furthers\n        if (computeListClosure.length && hierarchyY === computeListClosure[0].closureHierarchy) return true;\n      }\n\n      return false;\n    }));\n\n    if (foundHighestInHierarchy) return ret;\n\n    // We didn't found the higest task in the hierarchy so look at master tasks, its maybe there\n    tasksMaster.some((x) => {\n      const hierarchyX = Master1_0.getHierarchyLevelByIdTask(computeListClosure, x.id);\n\n      if (!x.isActive) return false;\n\n      // Look if this hierarchy is higher than the save one\n      if (ret.hierarchyLevel === false || (ret.hierarchyLevel > hierarchyX)) {\n        // Save the task to be the one that get to be removed (for now!)\n        ret.hierarchyLevel = hierarchyX;\n        ret.idTaskToRemove = x.id;\n        ret.isSlaveTask = false;\n        ret.isMasterTask = true;\n        ret.identifierSlave = false;\n\n        // If the task we have is the highest in hierarchy, no need to look furthers\n        if (computeListClosure.length && hierarchyX === computeListClosure[0].closureHierarchy) return true;\n      }\n      return false;\n    });\n\n    return ret;\n  }\n\n  /**\n   * Stop all tasks on every slave and master following a specific closure order\n   * (Some tasks must be closed before/after some others)\n   *\n   * WARNING RECURSIVE CALL\n   */\n  stopAllTaskOnEverySlaveAndMaster() {\n    return new PromiseCommandPattern({\n      func: async () => {\n        // close one of the task\n        // master or slave task\n        const {\n          idTaskToRemove,\n          isMasterTask,\n          isSlaveTask,\n          identifierSlave,\n          args,\n        } = this.chooseWhichTaskToStop();\n\n        // No more task to stop\n        if (idTaskToRemove === false) {\n          // Say something changed\n          this.somethingChangedAboutSlavesOrI();\n\n          return true;\n        }\n\n        if (isMasterTask) {\n          await this.getTaskHandler()\n            .stopTask(idTaskToRemove, args);\n\n          // Call next\n          return this.stopAllTaskOnEverySlaveAndMaster();\n        }\n\n        if (isSlaveTask) {\n          await this.removeTaskFromSlave(identifierSlave, idTaskToRemove, args);\n\n          // Call next\n          return this.stopAllTaskOnEverySlaveAndMaster();\n        }\n\n        return true;\n      },\n    });\n  }\n\n  /**\n   * PROGRAM stop to play the role\n   * @param {Object} args\n   * @override\n   */\n  stop() {\n    return new PromiseCommandPattern({\n      func: async () => {\n        // Say bye to every slaves\n        await this.stopAllTaskOnEverySlaveAndMaster();\n\n        await this.removeExistingSlave(this.slaves.map(x => x.programIdentifier));\n\n        // Stop the infinite loops\n        if (this.intervalFdCpuAndMemory) clearInterval(this.intervalFdCpuAndMemory);\n\n        if (this.intervalFdTasksInfos) clearInterval(this.intervalFdTasksInfos);\n\n        // Stop the communication system\n        await this.communicationSystem.stop();\n\n        this.active = false;\n\n        return true;\n      },\n    });\n  }\n\n  /**\n   * Send the given message and wait for the response\n   *\n   * HERE WE CREATE TWO EXECUTIONS LIFES\n   *\n   * Put isHeadBodyPattern = true if you want to use the headBodyPattern\n   *\n   * @param {Object} args\n   */\n  sendMessageAndWaitForTheResponse({\n    identifierSlave,\n    messageHeaderToSend,\n    messageBodyToSend,\n    messageHeaderToGet,\n    isHeadBodyPattern,\n\n    // Can be equals to undefined -> default timeout\n    timeoutToGetMessage,\n  }) {\n    return new PromiseCommandPattern({\n      func: () => new Promise((resolve, reject) => {\n        // We switch to the appropriated func\n        const sendMessageGoodFunc = () => {\n          if (isHeadBodyPattern) return this.sendMessageToSlaveHeadBodyPattern;\n\n          return this.sendMessageToSlave;\n        };\n\n        let errAlreadyReturned = false;\n\n        // Be ready to get the message from the slave before to send it the command\n        this.getMessageFromSlave(messageHeaderToGet, identifierSlave, timeoutToGetMessage)\n          // Job done\n          .then(resolve)\n          .catch((err) => {\n            if (!errAlreadyReturned) {\n              errAlreadyReturned = true;\n\n              return reject(err);\n            }\n\n            return false;\n          });\n\n        // Send the command to the slave\n        sendMessageGoodFunc()\n          .call(this, identifierSlave, messageHeaderToSend, messageBodyToSend)\n          .then(() => {\n            // It went well, no wait getMessageFromSlave to get the message\n            // If the message is not coming, getMessageFromSlave will timeout and result of an error\n\n            //\n            // Nothing to do here anymore Mate!\n            //\n          })\n          .catch((err) => {\n            // The getMessageFromSlave will automatically timeout\n            if (!errAlreadyReturned) {\n              errAlreadyReturned = true;\n\n              return reject(err);\n            }\n\n            return false;\n          });\n      }),\n    });\n  }\n}\n"]}